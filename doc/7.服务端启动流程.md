# 服务端启动流程代码

```java
EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer<SocketChannel>() {

                @Override
                public void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(new PrintServerHandler());
                }
            })
            .option(ChannelOption.SO_BACKLOG, 128)
            .childOption(ChannelOption.SO_KEEPALIVE, true);

    ChannelFuture f = b.bind(port).sync();
    f.channel().closeFuture().sync();
} finally {
    workerGroup.shutdownGracefully();
    bossGroup.shutdownGracefully();
}
```

- EventLoopGroup就是一个死循环，不停地检测IO事件，处理IO事件，执行任务

- `ServerBootstrap` 是服务端的一个启动辅助类，通过给他设置一系列参数来绑定端口启动服务

- `group(bossGroup, workerGroup)` 我们需要两种类型的人干活，一个是老板，一个是工人，老板负责从外面接活，接到的活分配给工人干，放到这里，`bossGroup`的作用就是不断地accept到新的连接，将新的连接丢给`workerGroup`来处理

- `channel(NioServerSocketChannel.class)` 表示服务端启动的是nio相关的channel，channel在netty里面是一大核心概念，可以理解为一条channel就是一个连接或者一个服务端bind动作

- `.handler(new SimpleServerHandler()` 表示服务器启动过程中，需要经过哪些流程，这里`SimpleServerHandler`最终的顶层接口为`ChannelHander`，是netty的一大核心概念，表示数据流经过的处理器，可以理解为流水线上的每一道关卡

- `childHandler(new ChannelInitializer)...`表示一条新的连接进来之后，该怎么处理，也就是上面所说的，老板如何给工人配活

- `ChannelFuture f = b.bind(8888).sync();` 这里就是真正的启动过程了，绑定8888端口，等待服务器启动完毕，才会进入下行代码

- `f.channel().closeFuture().sync();` 等待服务端关闭socket

- `bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully();` 关闭两组死循环

  

# bind操作入口

以下方法是 bind 入口

```java
public ChannelFuture bind(int inetPort) {
    return bind(new InetSocketAddress(inetPort));
}
```

通过端口号创建一个 `InetSocketAddress`，然后继续bind

```java
public ChannelFuture bind(SocketAddress localAddress) {
    // 校验服务启动需要的必要参数
    validate();
    if (localAddress == null) {
        throw new NullPointerException("localAddress");
    }
    // 绑定本地地址( 包括端口 )
    return doBind(localAddress);
}
```

```java
private ChannelFuture doBind(final SocketAddress localAddress) {
    // 初始化并注册一个 Channel 对象，因为注册是异步的过程，所以返回一个 ChannelFuture 对象。
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) { // 若发生异常，直接进行返回。
        return regFuture;
    }

  	//上述 Channel 的注册可能是异步的
    //这里分异步处理完成的处理逻辑和未完成添加监听器的处理逻辑
    //最终都是调用 doBind0进行绑定
  
    // 绑定 Channel 的端口，并注册 Channel 到 SelectionKey 中。
    if (regFuture.isDone()) { 
        // At this point we know that the registration was complete and successful.
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise); // 绑定
        return promise;
    } else {
        // Registration future is almost always fulfilled already, but just in case it's not.
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                System.out.println(Thread.currentThread() + ": PendingRegistrationPromise");
                Throwable cause = future.cause();
                if (cause != null) {
                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                    // IllegalStateException once we try to access the EventLoop of the Channel.
                    promise.setFailure(cause);
                } else {
                    // Registration was successful, so set the correct executor to use.
                    // See https://github.com/netty/netty/issues/2586
                    promise.registered();

                    doBind0(regFuture, channel, localAddress, promise); // 绑定
                }
            }
        });
        return promise;
    }
}
```

# 初始化与注册 Channel

```java
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // 创建 Channel 对象
        channel = channelFactory.newChannel();
        // 初始化 Channel 配置
        init(channel);
    } catch (Throwable t) {
        if (channel != null) { // 已创建 Channel 对象
            // channel can be null if newChannel crashed (eg SocketException("too many open files"))
            channel.unsafe().closeForcibly(); // 强制关闭 Channel
            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }

    // 注册 Channel 到 EventLoopGroup 中
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly(); // 强制关闭 Channel
        }
    }

    // If we are here and the promise is not failed, it's one of the following cases:
    // 1) If we attempted registration from the event loop, the registration has been completed at this point.
    //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
    // 2) If we attempted registration from the other thread, the registration request has been successfully
    //    added to the event loop's task queue for later execution.
    //    i.e. It's safe to attempt bind() or connect() now:
    //         because bind() or connect() will be executed *after* the scheduled registration task is executed
    //         because register(), bind(), and connect() are all bound to the same thread.

    return regFuture;
}
```

## 创建NioServerSocketChannel

ServerBootstrap在构造的过程中会传入```.channel(NioServerSocketChannel.class)```参数，作为创建 channel 的依据

```java
public B channel(Class<? extends C> channelClass) {
    if (channelClass == null) {
        throw new NullPointerException("channelClass");
    }
    return channelFactory(new ReflectiveChannelFactory<C>(channelClass));
}
```

返回的是根据通过反射创建对象的工厂类

```java
public class ReflectiveChannelFactory<T extends Channel> implements ChannelFactory<T> {

    /**
     * Channel 对应的类
     */
    private final Class<? extends T> clazz;

    public ReflectiveChannelFactory(Class<? extends T> clazz) {
        if (clazz == null) {
            throw new NullPointerException("clazz");
        }
        this.clazz = clazz;
    }

    @Override
    public T newChannel() {
        try {
            // 反射调用默认构造方法，创建 Channel 对象
            return clazz.getConstructor().newInstance();
        } catch (Throwable t) {
            throw new ChannelException("Unable to create Channel from class " + clazz, t);
        }
    }

    @Override
    public String toString() {
        return StringUtil.simpleClassName(clazz) + ".class";
    }

}
```

也就是服务端ServerBootstrap的启动，所创建的 channel 对象是NioServerSocketChannel

## NioServerSocketChannel的构造过程

会创建以下关键组件：

- Channel
- ChannelConfig
- ChannelId
- Unsafe
- Pipeline
- ChannelHander

上述无参反射实例化对象，调用的是无参构造方法

```java
public NioServerSocketChannel() {
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
}
```

DEFAULT_SELECTOR_PROVIDER是根据不同的平台创建出来的SelectorProvider对象

```java
private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
```

创建ServerSocketChannel

```java
private static ServerSocketChannel newSocket(SelectorProvider provider) {
    try {
        return provider.openServerSocketChannel();
    } catch (IOException e) {
        throw new ChannelException("Failed to open a server socket.", e);
    }
}
```

最后调用父类构造方法

```java
public NioServerSocketChannel(ServerSocketChannel channel) {
    //传入了默认感兴趣的事件OP_ACCEPT
    super(null, channel, SelectionKey.OP_ACCEPT);
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
```

追踪到父类AbstractNioChannel中

```java
protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    super(parent);
    this.ch = ch;
    this.readInterestOp = readInterestOp;
    try {
        ch.configureBlocking(false);
    } catch (IOException e) {
        try {
            ch.close();
        } catch (IOException e2) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        "Failed to close a partially initialized socket.", e2);
            }
        }

        throw new ChannelException("Failed to enter non-blocking mode.", e);
    }
}
```

简单地将前面 `provider.openServerSocketChannel();` 创建出来的 `ServerSocketChannel` 保存到成员变量，然后调用`ch.configureBlocking(false);`设置该channel为非阻塞模式，标准的jdk nio编程的玩法。这里的 `readInterestOp` 即前面层层传入的 `SelectionKey.OP_ACCEPT`

继续调用到父类

```java
protected AbstractChannel(Channel parent) {
    this.parent = parent;
    // 创建 ChannelId 对象
    id = newId();
    // 创建 Unsafe 对象
    unsafe = newUnsafe();
    // 创建 DefaultChannelPipeline 对象
    pipeline = newChannelPipeline();
}
```

unsafe 是通过AbstractNioMessageChannel类创建

```java
@Override
protected AbstractNioUnsafe newUnsafe() {
    return new NioMessageUnsafe();
}
```

pipeline也是创建的默认实现DefaultChannelPipeline

```java
protected DefaultChannelPipeline newChannelPipeline() {
    return new DefaultChannelPipeline(this);
}
```

```java
protected DefaultChannelPipeline(Channel channel) {
    this.channel = ObjectUtil.checkNotNull(channel, "channel");
    // succeededFuture 的创建
    succeededFuture = new SucceededChannelFuture(channel, null);
    // voidPromise 的创建
    voidPromise =  new VoidChannelPromise(channel, true);

    // 创建 Tail 及诶点
    tail = new TailContext(this);
    // 创建 Head 节点
    head = new HeadContext(this);

    // 相互指向
    head.next = tail;
    tail.prev = head;
}
```

## 初始化Channel

在上述创建完 Channel 后，会进行初始化

```java
@Override
void init(Channel channel) throws Exception {
    // 初始化 Channel 的可选项集合
    final Map<ChannelOption<?>, Object> options = options0();
    synchronized (options) {
        setChannelOptions(channel, options, logger);
    }

    // 初始化 Channel 的属性集合
    final Map<AttributeKey<?>, Object> attrs = attrs0();
    synchronized (attrs) {
        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
            @SuppressWarnings("unchecked")
            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();
            channel.attr(key).set(e.getValue());
        }
    }

    ChannelPipeline p = channel.pipeline();

    // 记录当前的属性
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry<ChannelOption<?>, Object>[] currentChildOptions;
    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));
    }
    synchronized (childAttrs) {
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
    }

    // 添加 ChannelInitializer 对象到 pipeline 中，用于后续初始化 ChannelHandler 到 pipeline 中。
    p.addLast(new ChannelInitializer<Channel>() {

        @Override
        public void initChannel(final Channel ch) throws Exception {
            System.out.println(Thread.currentThread() + ": user handler");
            final ChannelPipeline pipeline = ch.pipeline();

            // 添加配置的 ChannelHandler 到 pipeline 中
            // 也就是.handle 传入的ChannelHandler
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }

            // 添加 ServerBootstrapAcceptor 到 pipeline 中。
            // 使用 EventLoop 执行的原因，参见 https://github.com/lightningMan/netty/commit/4638df20628a8987c8709f0f8e5f3679a914ce1a
            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread() + ": ServerBootstrapAcceptor");
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }

    });
}
```

上述方法做了以下核心事情：

1. 设置option和attr
2. 设置新接入channel的option和attr
3. 加入新连接处理器

## 注册 Channel 到 EventLoopGroup 中

核心流程：

1. 首先在AbstractBootstrap 的initAndRegister()中，通过group().register(channel)，调用MultithreadEventLoopGroup 的register()方法。
2. 在MultithreadEventLoopGroup 的register()中调用next()获取一个可用的SingleThreadEventLoop，然后调用它的register()方法。
3. 在SingleThreadEventLoop 的register()方法中，通过channel.unsafe().register(this, promise)方法获取channel的unsafe()底层IO 操作对象，然后调用它的register()。
4. 在AbstractUnsafe 的register()方法中，调用register0()方法注册Channel 对象。
5. 在AbstractUnsafe 的register0()方法中，调用AbstractNioChannel 的doRegister()方法。
6. AbstractNioChannel 的doRegister()方法调用javaChannel().register(eventLoop().selector, 0, this)将Channel对应的Java NIO 的SockerChannel 对象注册到一个eventLoop 的Selector 中，并且将当前Channel 作为attachment。

所有的客户端的I/O请求都将通过该NioServerSocketChannel接收并转发，这一光荣的任务交给了group()，也就是bossGroup来处理

```java
ChannelFuture regFuture = config().group().register(channel);
```

```java
@Override
public ChannelFuture register(Channel channel) {
    return next().register(channel);
}
```

```java
@Override
public ChannelFuture register(Channel channel) {
    return next().register(channel);
}
```

bossGroup传入的是1，底层的EventLoopGroup 只有一个事件执行器，怎么轮询都是同一个

```java
@Override
public ChannelFuture register(Channel channel) {
    return register(new DefaultChannelPromise(channel, this));
}

@Override
public ChannelFuture register(final ChannelPromise promise) {
    ObjectUtil.checkNotNull(promise, "promise");
    // 注册 Channel 到 EventLoop 上
    promise.channel().unsafe().register(this, promise);
    // 返回 ChannelPromise 对象
    return promise;
}
```

```java
@Override
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    // 校验传入的 eventLoop 非空
    if (eventLoop == null) {
        throw new NullPointerException("eventLoop");
    }
    // 校验未注册
    if (isRegistered()) {
        promise.setFailure(new IllegalStateException("registered to an event loop already"));
        return;
    }
    // 校验 Channel 和 eventLoop 匹配
    if (!isCompatible(eventLoop)) {
        promise.setFailure(new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
        return;
    }

    // 设置 Channel 的 eventLoop 属性
    AbstractChannel.this.eventLoop = eventLoop;

    // 在 EventLoop 中执行注册逻辑
    if (eventLoop.inEventLoop()) {
        register0(promise);
    } else {
        try {
            eventLoop.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread() + ": register");

                    register0(promise);
                }
            });
        } catch (Throwable t) {
            logger.warn("Force-closing a channel whose registration task was not accepted by an event loop: {}", AbstractChannel.this, t);
            closeForcibly();
            closeFuture.setClosed();
            safeSetFailure(promise, t);
        }
    }
}
```

最终会将register0逻辑交给 EventLoop 线程执行

```java
private void register0(ChannelPromise promise) {
    try {
        // check if the channel is still open as it could be closed in the mean time when the register
        // call was outside of the eventLoop
        if (!promise.setUncancellable() // TODO 1001 Promise
                || !ensureOpen(promise)) { // 确保 Channel 是打开的
            return;
        }
        // 记录是否为首次注册
        boolean firstRegistration = neverRegistered;

        // 执行注册逻辑
        doRegister();

        // 标记首次注册为 false
        neverRegistered = false;
        // 标记 Channel 为已注册
        registered = true;

        // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
        // user may already fire events through the pipeline in the ChannelFutureListener.
        pipeline.invokeHandlerAddedIfNeeded();

        // 回调通知 `promise` 执行成功
        safeSetSuccess(promise);

        // 触发通知已注册事件
        pipeline.fireChannelRegistered();

        // TODO 芋艿
        // Only fire a channelActive if the channel has never been registered. This prevents firing
        // multiple channel actives if the channel is deregistered and re-registered.
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
            }
        }
    } catch (Throwable t) {
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    }
}
```

javaChannel()方法返回的便是之前创建的JDK中的SelectableChannel，调用register注册到一个Selector上，不过这个Selector是包含在NioEventLoop中的。**注意，这里注册的InterestOp是0，代表对任何事件都不感兴趣，此时即便有客户端的连接过来了，Server也不会响应。**既如此，那客户端连接上来后，如何触发后续事件呢？

```java
@Override
protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        } catch (CancelledKeyException e) {
            // TODO TODO 1003 doRegister 异常
            if (!selected) {
                // Force the Selector to select now as the "canceled" SelectionKey may still be
                // cached and not removed because no Select.select(..) operation was called yet.
                eventLoop().selectNow();
                selected = true;
            } else {
                // We forced a select operation on the selector before but the SelectionKey is still cached
                // for whatever reason. JDK bug ?
                throw e;
            }
        }
    }
}
```

在后续register0方法中

```java
private void register0(ChannelPromise promise) {
    try {
        ...
        doRegister();
        ...
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
                ...
}
```

当注册完毕后，由于autoRead默认为true，所以代码会执行beginRead这个方法

```java
@Override
protected void doBeginRead() throws Exception {
    ...
    final int interestOps = selectionKey.interestOps();
    if ((interestOps & readInterestOp) == 0) {
        selectionKey.interestOps(interestOps | readInterestOp);
    }
}
```

最后我们发现这里重新对感兴趣的动作进行关注，readInterestOp是我们在构建NioServerSocketChannel的时候就传入的OP_ACCEPT



对于Server侧，Netty允许创建两个EventLoopGroup，每个都是多线程模式。其中：

- 将ServerChannel与parentGroup绑定。parentGroup负责运行的逻辑是：接收来自客户端的连接请求，然后将客户端的Channel绑定到childGroup上；
- 将ClientChannel与childGroup绑定。该child EventLoop负责运行的逻辑是：客户端的Channel与Server的数据传输通信逻辑的处理；
- 每一个EventLoop可以绑定到多个Channel，而不同的Channel虽然运行在不同的线程中，但都注册到同一个Register上（详见NioEventLoop.run）